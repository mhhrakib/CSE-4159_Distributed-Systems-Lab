/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "matrix_Op.h"
#include<stdio.h>
#include <math.h>


// takes pointer to a matrix and prints the matrix
void print_matrix(matrix *mat) {
	printf("Printing result matrix\n");
    int i,j;
    int cnt = 0;
    int r = mat->row;
    int c = mat->col;
    double *x = mat->mat.mat_val;

    for(i = 0; i < r; i++){
        for(j = 0; j < c; j++){
            printf("%.4lf\t", x[cnt++]);
        }
        printf("\n");
    }

}


// checks if dimensions of the matrices to be added or multiplied is correct
// returns 1 if correct
// returns 0 if not correct 
int check_dimension(int rowA, int colA, int rowB, int colB, int choice) {
	if(choice == 1) {
		if (rowA == rowB && colA == colB) {
			return 1;
		}
		else {
			printf("\nDimension of first matrix must be equal to second matrix!!!\n");
			return 0;
		}
	}
	else if(choice == 2) {
		if(colA != rowB) {
			printf("\nMatrices cannot be multiplied, row of first matrix is not equal to column of second matrix.\n");
			return 0;
		}
	}
	return 1;
}

//takes pointer to matrices represented as 1D array and sizes of the matrices to be added or multiplied
// sets the value of the argument to matrices to be added or multiplied, that will be passed to server, 
void set_argument_add_mul(data1 *arg, int rowA, int colA, int rowB, int colB, double *matA, double *matB, char opr) {
	arg->operator = opr;
	arg->A.row = rowA;
	arg->A.col = colA;
	arg->B.row = rowB;
	arg->B.col = colB;

	int lenA, lenB;
	lenA = rowA*colA;
	lenB = rowB*colB;

	arg->A.mat.mat_len = lenA;
	arg->A.mat.mat_val = (double*) malloc(lenA*sizeof(double));

	arg->B.mat.mat_len = lenB;
	arg->B.mat.mat_val = (double*) malloc(lenB*sizeof(double));

	int i, cnt = 0;
	for(i = 0; i < lenA; i++)
		arg->A.mat.mat_val[i] = matA[cnt++];
	cnt = 0;
	for(i = 0; i < lenB; i++)
		arg->B.mat.mat_val[i] = matB[cnt++];

}

//calculate minor matrix
void minor(double b[100][100],double a[100][100],int i,int n)
{
    int j,l,h=0,k=0;
    for(l=1; l<n; l++)
        for( j=0; j<n; j++)
        {
            if(j == i)
                continue;
            b[h][k] = a[l][j];
            k++;
            if(k == (n-1)) {
                h++;
                k=0;
            }
        }
}

//calculate a^b
double power(int a, int b) {
	double prod = 1.0;
	int i;
	for(int i = 0; i < b; i++) {
		prod *= a;
	}

	return prod;
}

//calculate determinant
double det(double a[100][100],int n)
{
    int i;
    double b[100][100],sum=0;
    if (n == 1)
        return a[0][0];
    else if(n == 2)
        return (a[0][0]*a[1][1]-a[0][1]*a[1][0]);
    else
        for(i=0; i<n; i++)
        {
            minor(b,a,i,n);	// read function
            sum = (double) (sum+a[0][i]* power(-1,i)*det(b,(n-1)));	// read function	// sum = determinant matrix
        }
    return sum;
}

//takes pointer to matrices represented as 1D array and sizes of the matrices to be added or multiplied
// sets the value of the argument to matrices to be inversed or transposed, that will be passed to server, 
void set_argument_inv_tra(data2 *arg, int rowA, int colA, double *matA, char opr) {
	arg->operator = opr;
	arg->A.row = rowA;
	arg->A.col = colA;

	int lenA;
	lenA = rowA*colA;

	arg->A.mat.mat_len = lenA;
	arg->A.mat.mat_val = (double*) malloc(lenA*sizeof(double));

	int i, cnt = 0;
	for(i = 0; i < lenA; i++)
		arg->A.mat.mat_val[i] = matA[cnt++];
}

//client-side function for processing user inputs and making remote procedure call
void
calculate_prog_1(char *host)
{
	CLIENT *clnt;
	matrix  *result_1;
	data1  add_1_arg;
	matrix  *result_2;
	data1  mul_1_arg;
	matrix  *result_3;
	data2  inv_1_arg;
	matrix  *result_4;
	data2  tra_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, CALCULATE_PROG, CALCULATE_VER, "tcp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	printf("Welcome\n");
	int choice;
	int rowA, colA, rowB, colB, cnt = 0;
	printf("\nWhich type of operation do you want to perform:\n1. ADD\n2. MULTIPLICATION\n3. INVERSE\n4. TRANPOSE\n5. Quit\n");

    //while(1 == 1) {
	printf("\nEnter your choice: ");
	scanf("%d",&choice);
	//printf("%d\n", choice);

	if(choice == 5) {
		//break;
		exit(1);
	}

	if(choice == 3 || choice == 4) {
		printf("\nEnter number of row for the matrix: ");
		scanf("%d", &rowA);
		printf("\nEnter number of col for the matrix: ");
		scanf("%d", &colA);
		if(choice == 3) {
			if(rowA != colA) {
				printf("\nMatrix must be square to be invertible\nPlease try again\n");
				exit(1);
			}
		}
	}

	else if (choice ==  1 || choice == 2) {
		printf("\nEnter number of row for first matrix: ");
		scanf("%d", &rowA);
		printf("\nEnter number of col for first matrix: ");
		scanf("%d", &colA);

		printf("\nEnter number of row for second matrix: ");
		scanf("%d", &rowB);
		printf("\nEnter number of col for second matrix: ");
		scanf("%d", &colB);

		if(check_dimension(rowA, colA, rowB, colB, choice) == 0) {
			printf("Please, try again with valid matrix dimension\n");
			exit(1);
			//continue;
		}
	}

	else {
		printf("Please enter a valid choice\n");
		//continue;
	}

	//printf("row = %d col = %d", rowA, colA);

	if(choice == 1 || choice == 2) {
		printf("\nEnter the elements for the first matrix:\n");
	}

	else {
		printf("\nEnter the elements for the matrix:\n");
	}

	double matA[rowA][colA];
	double matLA[rowA*colA];
	int i,j;
	for(i = 0; i < rowA; i++) {
		for(j = 0; j < colA; j++) {
			scanf("%lf", &matA[i][j]);
			matLA[cnt++] = matA[i][j];
		}
	}

	if(choice == 3) {
		double deter = det(matA, rowA);
		if(fabs(deter) > 10e-7) {
			printf("\nMatrix is not invertible, as determinant is 0\n");
			exit(0);
		}
	}


	if (choice == 1 || choice == 2) {

		double matB[rowB][colB];
		double matLB[rowB*colB];
		printf("\nEnter the elements for the second matrix:\n");

		cnt = 0;
		for(i = 0; i < rowB; i++) {
			for(j = 0; j < colB; j++) {
				scanf("%lf", &matB[i][j]);
				matLB[cnt++] = matB[i][j];
			}
		}

		if(choice == 1) {
			set_argument_add_mul(&add_1_arg, rowA, colA, rowB, colB, matLA, matLB, '1');
			result_1 = add_1(&add_1_arg, clnt);
			if (result_1 == (matrix *) NULL) {
				clnt_perror (clnt, "call failed");
			}
			print_matrix(result_1);
		}
		else if (choice == 2) {
			set_argument_add_mul(&mul_1_arg, rowA, colA, rowB, colB, matLA, matLB, '2');
			result_2 = mul_1(&mul_1_arg, clnt);
			if (result_2 == (matrix *) NULL) {
				clnt_perror (clnt, "call failed");
			}
			print_matrix(result_2);

		}
	}

	else if(choice == 3 || choice == 4) {
		if(choice == 3) {
			set_argument_inv_tra(&inv_1_arg, rowA, colA, matLA, '3');
			result_3 = inv_1(&inv_1_arg, clnt);
			if (result_3 == (matrix *) NULL) {
				clnt_perror (clnt, "call failed");
			}
			print_matrix(result_3);
		}
		else if(choice == 4) {
			set_argument_inv_tra(&tra_1_arg, rowA, colA, matLA, '4');
			result_4 = tra_1(&tra_1_arg, clnt);
			if (result_4 == (matrix *) NULL) {
				clnt_perror (clnt, "call failed");
			}
			print_matrix(result_4);
		}
	}

	//}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc  <  2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	calculate_prog_1(host);
	exit (0);
}
